<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Gocam : Detects the board state of a go game given an image" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Gocam</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/vjsingh/gocam">View on GitHub</a>

          <h1 id="project_title">Gocam</h1>
          <h2 id="project_tagline">Detects the board state of a go game given an image</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/vjsingh/gocam/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/vjsingh/gocam/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>Gocam by Varun Singh</h3>

<p>This was my capstone project for my Machine Learning class at Brown.</p>

<h3>Abstract</h3>
<p>Gocam provides the beginnings of a solution to a real problem: the ability to play a go game on a physical board, but record the game on a computer for playback and sharing. My Gocam program takes in an image file, and then given where the four corners of the go board are, attempts to reliably figure out the state of the board (i.e. for every grid spot, whether it is empty, black, or white). Future improvements include: Detecting the four corners automatically (I began work on this), using pixel colors to more reliably detect the white/black/no stone split, and ultimately taking in a video stream, detecting when a move is played, and then recording an entire game automatically.</p>

<h3>Method</h3>

<p> Original Image>
<img src="./images/mine/board1.jpg"> </img>

<p>First I convert the image into black and white. Then, I get the corners of the board from as input from the user. I then do a projective transformation to make the grid square and uniform. This entails creating a projective 'tform' object in matlab, mapping the the four corners to (0,0) (newImageSize,0) (newImageSize,newImageSize), and (0, newImageSize). I then crop the new image so that it contains only the board. This results in a new image (projectedImage), which contains only the board, and the game grid should now be square and uniform.</p>
<img src="./images/mine/projectiveTransform.jpg"> </img>

<p> Then, I attempt to find the edges of the actual game grid (as opposed to the entire board). I do this by first finding the edges in the image, and then finding both hough lines and hough circles from the edges in the image. Finally, I take the extreme in the top/right/bottom/left directions of all the lines and the (midpoints of the) circles, which are beyond a 5 px margin of the sides of the image (since sometimes the edge of the board still shows up after the projective transformation), and these are the edges of the grid.</p>
<p> All Lines, Extreme Lines, All Circles</p>
<img src="./images/mine/allLines.jpg"> </img>
<img src="./images/mine/extremeLines.jpg"> </img>
<img src="./images/mine/circles.jpg"> </img>

<p>With the edges of the game grid, I can easily compute the positions of every 19x19 grid spot on the image. I simply divide the grid up from top to bottom and left to right into 19x19 even locations, which produces the entire game grid. </p>
<img src="./images/mine/gridPositions.jpg"> </img>

<p>Then, I go through every single point on the game grid, and compute whether there is a black, white, or no stone there. This is the lengthiest operation by far. To do this, I established a low and high threshold for the colors of the stones. This is somewhat arbitrary, since its only based on my limited training data. Suggestions for further improvements below</p>
<p> At each grid location, I look in a circle of radius HALF that as measured by my circle detector. This is because we only need a small area to reliably detect the stone, and the grid positions might be slightly off, which means the full circle might go outside where the stone is. Then, I simply take the average of all the pixels within that radius at each grid location, and check if it is below a threshold (.3 for black) or above a threshold (.65 for black). If it's in the middle, that means there's no stone there.</p>
<p> Finally, I convert the board game into the <a href="http://senseis.xmp.net/?SmartGameFormat"> SGF </a> format. 

<h3>Results</h3>
<p> Gocam succesfully determined the board game state, with 100% accuracy, of 2 out of my 3 main test images. The third image was difficult because the white stones and board color were almost the same. </p>
<h3>Further Improvements</h3>

<p>If you prefer to not use the automatic generator, push a branch named <code>gh-pages</code> to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator written by our own Tom Preston-Werner. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.</p>

<p>Created by <a href="https://github.com/vjsingh" class="user-mention">@mention</a> </p>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Gocam maintained by <a href="https://github.com/vjsingh">vjsingh</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
